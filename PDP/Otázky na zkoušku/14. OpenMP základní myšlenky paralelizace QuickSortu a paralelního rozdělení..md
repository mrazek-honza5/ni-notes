# QuickSort
- Rozděl a panuj
- Datově citlivý (v praxi většinou nejrychlejší)
- In-place (nepotřebuje extra paměť)
- Nestabilní (může prohodit stejné prvky)

# Sekvenční algoritmus
```cpp
void swap(int* A, long i, long j) 
{ 
	int temp = A[i]; 
	A[i] = A[j]; 
	A[j] = temp; 
} 

long seq_partition_L(int* A, long lo, long hi) //varianta Lomuto 
{ 
	long pivot = A[hi]; //za pivota je zvolen poslední prvek. 
	long i = lo; 
	for (long j = lo; j < hi; j++) 
		if (A[j] < pivot) swap(A, i++, j); //prohození A[i] a A[j], pak inkrementace i 
	swap(A, i, hi); //umístění pivota na správnou pozici 
	return i; //vrácení pozice pivota 
} 
	
void seq_quicksort(int* A, long lo, long hi) 
{ 
	if (lo < hi) { 
		long r = seq_partition_L(A, lo, hi); 
		seq_quicksort(A, lo, r - 1); //rekurzivní zpracování levé části 
		seq_quicksort(A, r + 1, hi); //rekurzivní zpracování pravé části 
	} 
}
```

## Lomutova varianta partitioning
- Máme dva ukazatele $i$, $j$, jako pivot se zvolí poslední prvek pole
- $j$ se vždy posune o jedničku, $i$ pouze tehdy když mám vpravo číslo vyšší, než pivot, pokud ne, tak inkrementuji jen $j$ dokud nenarazím na další číslo menží, než pivot. Poté prohodím tato dvě čísla (to na které jsem narazil a to, na které ukazuje $i$)

# Základní paralelizace
```cpp
void swap(int* A, long i, long j) 
{ 
	int temp = A[i]; 
	A[i] = A[j]; 
	A[j] = temp; 
} 

long seq_partition_L(int* A, long lo, long hi) //varianta Lomuto 
{ 
	long pivot = A[hi]; //za pivota je zvolen poslední prvek. 
	long i = lo; 
	for (long j = lo; j < hi; j++) 
		if (A[j] < pivot) swap(A, i++, j); //prohození A[i] a A[j], pak inkrementace i 
	swap(A, i, hi); //umístění pivota na správnou pozici 
	return i; //vrácení pozice pivota 
} 

void par_quicksort(int* A, long lo, long hi) 
{
	#pragma omp parallel //vytvoření vláken 
	{ 
		#pragma omp single //zpracování kořene stromu rekurzivních volání
		par_quicksort_rec(A, lo, hi);
	}
}
	
void par_quicksort_rec(int* A, long lo, long hi) 
{ 
	if (lo < hi) { 
		long r = seq_partition_L(A, lo, hi); 
		#pragma omp task
		par_quicksort_rec(A, lo, r - 1); //rekurzivní zpracování levé části 
		#pragma omp task
		par_quicksort_rec(A, r + 1, hi); //rekurzivní zpracování pravé části 
	} 
}
```

- Problémy
	- Příliš malé tasky => prahování
		- Úlohy budeme vytvářet pouze do nějaké "hloubky"
		- Určím si experimentálně nějakou hodnotu $k$ a vypočítám `threshold = (hi - lo + 1) / omp_get_num_threads() / k`
	- Optimalizace odstranění koncové rekurze
		- Vlákno vytváří pouze jednu novou úlohu a druhou část rovnou zpracuje
		```cpp
		void par_quicksort_rec(int* A, long lo, long hi) 
		{ 
			while (lo < hi) { 
				long r = seq_partition_L(A, lo, hi); 
				#pragma omp task
				par_quicksort_rec(A, lo, r - 1); 
				
				lo = r + 1;
			} 
		}
		```
	- Sekvenční partitioning => paralelizovat toto
		- Jedná se o složitou operaci i implementaci, hlavně co se týká vyvažování zátěže
		- Má to ale velký vliv na výkon
		- Využívá se Hoareova partitioningu
			- Máme také dva indexy, ale jeden běží zleva a druhý zprava
			- Pivot je číslo na konci
			- Porovnávám
				- Pokud jsou obě čísla nevyhovují, prohodím je
				- Pokud obě vyhovují, jen inkrementuji indexy
				- Pokud vyhovuje jeden, inkrementuji druhý a jedu dál. 
				- Až se střetnou indexy / popř se minou, tak je zkoriguji, posunu aby byly na stejném místě a poté prohodím s pivotem
			- Paralelismus 
				- Vnořený (musí být povolené pomocí funkce `omp_set_max_active_levels(hloubka)`)
		- Dál se nebudu snažit to pochopit, je toho hrozně moc :D 